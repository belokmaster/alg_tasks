package main

import (
	"slices"
)

//  Учитывая две двоичные строки a и b, верните их сумму в виде двоичной строки.

func addBinary(a string, b string) string {
	// Переменная для хранения переноса
	carry := 0

	// Преобразуем строки в срезы рун
	A := []rune(a)
	B := []rune(b)

	// Переворачиваем срезы, чтобы начинать с младших разрядов
	slices.Reverse(A)
	slices.Reverse(B)

	// Срез для хранения результата
	res := []rune{}

	// Проходим по строкам с учетом возможной разной длины
	for i := 0; i < len(A) || i < len(B); i++ {
		// Переменная для хранения суммы текущего разряда
		sum := 0

		// Если текущий бит строки A равен 1, увеличиваем сумму
		if i < len(A) && A[i] == '1' {
			sum++
		}

		// Если текущий бит строки B равен 1, увеличиваем сумму
		if i < len(B) && B[i] == '1' {
			sum++
		}

		// Добавляем перенос
		sum += carry

		// Проверяем возможные значения суммы и определяем новый бит и перенос
		if sum == 3 { // 1 + 1 + 1 (включая перенос)
			res = append(res, '1')
			carry = 1 // Перенос будет 1
		} else if sum == 2 { // 1 + 1 или 0 + 1 + 1 (включая перенос)
			res = append(res, '0')
			carry = 1 // Перенос будет 1
		} else if sum == 1 { // 1 или 0 + 1 (без переноса)
			res = append(res, '1')
			carry = 0 // Перенос будет 0
		} else { // sum == 0, если оба бита 0 и перенос 0
			res = append(res, '0')
			carry = 0 // Перенос остается 0
		}
	}

	// Если остался перенос, добавляем его в результат
	if carry > 0 {
		res = append(res, '1')
	}

	// Переворачиваем результат, так как мы строили его в обратном порядке
	slices.Reverse(res)

	// Преобразуем срез рун обратно в строку
	r := string(res)
	return r
}

/*
func main() {
	// Пример использования
	fmt.Println(addBinary("11", "1"))      // Вывод: "100"
	fmt.Println(addBinary("1010", "1011")) // Вывод: "10101"
}
*/
